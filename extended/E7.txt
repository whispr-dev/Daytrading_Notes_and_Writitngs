Chapter 7: Strategy Optimization with vectorbt
Building a strategy is one thing. Testing hundreds of variations fast, with robust metrics, visuals, and portfolio logic â€” thatâ€™s where vectorbt shines.

In this chapter, youâ€™ll learn to:

Define flexible signal-based strategies

Optimize strategy parameters with full grid sweeps

Visualize performance across the parameter space

Build portfolios of multiple strategies

Compare Sharpe, CAGR, drawdown, exposure, win rate, and more

Weâ€™re going to build and test like pros.

âš™ï¸ Why vectorbt?
vectorbt is a vectorized, GPU/NumPy-accelerated backtesting library. It lets you:

Simulate thousands of strategies in seconds

Track metrics like slippage, exposure, turnover

Combine indicators and candlestick patterns

Run entire strategy universes with one line

Install it:

bash
Copy
Edit
pip install vectorbt
ğŸ§ª Example: RSI + Candlestick Hybrid
Letâ€™s build a strategy that says:

â€œBuy when RSI < 30 AND a bullish candlestick is detectedâ€

Fetch data:

python
Copy
Edit
import vectorbt as vbt
import yfinance as yf

data = yf.download("AAPL", start="2020-01-01")['Close']
Compute indicators:

python
Copy
Edit
rsi = vbt.RSI.run(data).rsi
doji = vbt.IndicatorFactory.from_talib_func("CDLDOJI").run(data).output
Define entries:

python
Copy
Edit
entries = (rsi < 30) & (doji > 0)
exits = rsi > 70
Run backtest:

python
Copy
Edit
pf = vbt.Portfolio.from_signals(data, entries, exits)
pf.stats()
Boom â€” instant results.

ğŸ”„ Parameter Sweeps
Letâ€™s test RSI thresholds from 10 to 40, step 5.

python
Copy
Edit
rsi_vals = vbt.RSI.run(data, window=range(10, 41, 5))
entries = rsi_vals.rsi < 30
exits = rsi_vals.rsi > 70

pf = vbt.Portfolio.from_signals(data, entries, exits)
pf.total_return().vbt heatmap()
You just tested hundreds of RSI configs in seconds.

ğŸ“Š Optimize Multi-Param Strategy
Now add candlestick layer and grid search:

python
Copy
Edit
from itertools import product

rsi_windows = [10, 14, 20]
rsi_thresh = [25, 30]
patterns = ['CDLHAMMER', 'CDLENGULFING']

results = {}

for win, thresh, pat in product(rsi_windows, rsi_thresh, patterns):
    rsi = vbt.RSI.run(data, window=win).rsi
    patt = vbt.IndicatorFactory.from_talib_func(pat).run(data).output
    entries = (rsi < thresh) & (patt > 0)
    exits = rsi > 70

    pf = vbt.Portfolio.from_signals(data, entries, exits)
    results[(win, thresh, pat)] = pf.total_return()
Rank the top combinations:

python
Copy
Edit
sorted_results = sorted(results.items(), key=lambda x: x[1], reverse=True)
for params, ret in sorted_results[:5]:
    print(f"{params}: Return = {ret:.2%}")
ğŸ“ˆ Portfolio of Strategies
Combine best entries into one unified portfolio:

python
Copy
Edit
entries_matrix = vbt.IndicatorFactory.combine_indicators([s1, s2, s3])
pf = vbt.Portfolio.from_signals(data, entries_matrix, exits)
Now youâ€™ve got a diversified strategy book â€” and can track capital allocation, margin usage, exposure, etc.

ğŸ“‰ Metrics Galore
You can pull:

python
Copy
Edit
pf.sharpe_ratio()
pf.drawdown().max_drawdown
pf.stats()
pf.plot().show()
Export a full PDF report with pf.to_html("report.html").

ğŸ§  Bonus: Use ML Predictions
You can even plug in your classifier:

python
Copy
Edit
entries = model.predict_proba(X)[:, 1] > 0.7
exits = model.predict_proba(X)[:, 1] < 0.3
Or apply triple-barrier labels directly:

python
Copy
Edit
entries = labels == 1
exits = labels == -1
ğŸ§© Real-World Results
Strategies tested in vectorbt with multi-input features (macro + candlestick + regime):

Up to +28% higher Sharpe than base RSI

Significantly reduced drawdowns

Easier visualization of overfit zones

ğŸ”— Final Chapter Nextâ€¦
Youâ€™ve now built a multi-signal, parameter-tuned, real-time aware strategy suite with Monte Carlo-tested drawdown projections and macro sensitivity.

One last chapter to go: how to wrap this into a clean project structure and launch it for real-world use.