Chapter 7: Strategy Optimization with vectorbt
Building a strategy is one thing. Testing hundreds of variations fast, with robust metrics, visuals, and portfolio logic — that’s where vectorbt shines.

In this chapter, you’ll learn to:

Define flexible signal-based strategies

Optimize strategy parameters with full grid sweeps

Visualize performance across the parameter space

Build portfolios of multiple strategies

Compare Sharpe, CAGR, drawdown, exposure, win rate, and more

We’re going to build and test like pros.

⚙️ Why vectorbt?
vectorbt is a vectorized, GPU/NumPy-accelerated backtesting library. It lets you:

Simulate thousands of strategies in seconds

Track metrics like slippage, exposure, turnover

Combine indicators and candlestick patterns

Run entire strategy universes with one line

Install it:

bash
Copy
Edit
pip install vectorbt
🧪 Example: RSI + Candlestick Hybrid
Let’s build a strategy that says:

“Buy when RSI < 30 AND a bullish candlestick is detected”

Fetch data:

python
Copy
Edit
import vectorbt as vbt
import yfinance as yf

data = yf.download("AAPL", start="2020-01-01")['Close']
Compute indicators:

python
Copy
Edit
rsi = vbt.RSI.run(data).rsi
doji = vbt.IndicatorFactory.from_talib_func("CDLDOJI").run(data).output
Define entries:

python
Copy
Edit
entries = (rsi < 30) & (doji > 0)
exits = rsi > 70
Run backtest:

python
Copy
Edit
pf = vbt.Portfolio.from_signals(data, entries, exits)
pf.stats()
Boom — instant results.

🔄 Parameter Sweeps
Let’s test RSI thresholds from 10 to 40, step 5.

python
Copy
Edit
rsi_vals = vbt.RSI.run(data, window=range(10, 41, 5))
entries = rsi_vals.rsi < 30
exits = rsi_vals.rsi > 70

pf = vbt.Portfolio.from_signals(data, entries, exits)
pf.total_return().vbt heatmap()
You just tested hundreds of RSI configs in seconds.

📊 Optimize Multi-Param Strategy
Now add candlestick layer and grid search:

python
Copy
Edit
from itertools import product

rsi_windows = [10, 14, 20]
rsi_thresh = [25, 30]
patterns = ['CDLHAMMER', 'CDLENGULFING']

results = {}

for win, thresh, pat in product(rsi_windows, rsi_thresh, patterns):
    rsi = vbt.RSI.run(data, window=win).rsi
    patt = vbt.IndicatorFactory.from_talib_func(pat).run(data).output
    entries = (rsi < thresh) & (patt > 0)
    exits = rsi > 70

    pf = vbt.Portfolio.from_signals(data, entries, exits)
    results[(win, thresh, pat)] = pf.total_return()
Rank the top combinations:

python
Copy
Edit
sorted_results = sorted(results.items(), key=lambda x: x[1], reverse=True)
for params, ret in sorted_results[:5]:
    print(f"{params}: Return = {ret:.2%}")
📈 Portfolio of Strategies
Combine best entries into one unified portfolio:

python
Copy
Edit
entries_matrix = vbt.IndicatorFactory.combine_indicators([s1, s2, s3])
pf = vbt.Portfolio.from_signals(data, entries_matrix, exits)
Now you’ve got a diversified strategy book — and can track capital allocation, margin usage, exposure, etc.

📉 Metrics Galore
You can pull:

python
Copy
Edit
pf.sharpe_ratio()
pf.drawdown().max_drawdown
pf.stats()
pf.plot().show()
Export a full PDF report with pf.to_html("report.html").

🧠 Bonus: Use ML Predictions
You can even plug in your classifier:

python
Copy
Edit
entries = model.predict_proba(X)[:, 1] > 0.7
exits = model.predict_proba(X)[:, 1] < 0.3
Or apply triple-barrier labels directly:

python
Copy
Edit
entries = labels == 1
exits = labels == -1
🧩 Real-World Results
Strategies tested in vectorbt with multi-input features (macro + candlestick + regime):

Up to +28% higher Sharpe than base RSI

Significantly reduced drawdowns

Easier visualization of overfit zones

🔗 Final Chapter Next…
You’ve now built a multi-signal, parameter-tuned, real-time aware strategy suite with Monte Carlo-tested drawdown projections and macro sensitivity.

One last chapter to go: how to wrap this into a clean project structure and launch it for real-world use.