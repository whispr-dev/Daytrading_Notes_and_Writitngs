üìñ Daytrading Reinvented: Python, AI, and the Future of Precision Trading
Introduction
The New Era of Daytrading

Why Python + AI is the Modern Trader's Best Ally

Chapter 1: Core Concepts for Daytraders
Descriptive Statistics for Traders (mean, median, std dev, skew, kurtosis)

Probability Distributions (Normal vs Binomial relevance)

Correlation & Covariance in Stocks

Central Limit Theorem and why it matters

Hypothesis Testing for strategy validation

Confidence Intervals for forecasts

Python Examples: statistical analysis of a real dataset

Chapter 2: Building Your Daytrading Crystal Ball
Real-Time Data Acquisition using yfinance

Support and Resistance Level Detection

Anomaly Detection with Lorentzian Distance

Live Candlestick Charting using Plotly

News Sentiment Scraping

Python Examples: Streamlit-based trading dashboard 

Chapter 3: Machine Learning Models for Intraday Predictions
LSTM Neural Networks for short-term forecasts 

Training models on minute-level stock data

Deploying Predictive Systems in Live Trading

Python Example: LSTM model predicting AAPL's next 10 minutes

Chapter 4: Statistical and AI-Based Options Trading
Scraping and Analyzing Option Chains

Calculating Greeks and Theoretical Pricing with Black-Scholes

AI-assisted Trade Signal Generation

Python Example: Option bot that suggests buy/sell based on Greeks 
‚Äã

Chapter 5: Forecasting with Monte Carlo Simulations
Historical vs Implied Volatility

Simulating Thousands of Future Price Paths

Estimating Probabilities of Price Targets

Python Example: Monte Carlo simulations with yfinance and numpy 

Chapter 6: Stock Screening and Smart Picking
Implementing Joel Greenblatt's Magic Formula

Automating Fundamental Screening

Using AI for Quality-Value Filters

Python Example: Magic Formula applied via automated scraping 

Chapter 7: XGBoost and Model Optimization for Traders
Gradient Boosting Basics

Hyperparameter Tuning Techniques

Real-World Application to Predict Stock Price Movement

Python Example: XGBoost regression model for stock predictions 

Chapter 8: Best Practices in Trading Data Science
Proper Data Splitting (Train/Validation/Test)

Temporal Splits for Financial Data

Preventing Overfitting in Market Models

Python Examples: train_valid_test_split for financial time series 

Conclusion
The Path Forward: AI-Assisted Human Traders

Responsible Usage of Algorithms

Continuous Learning and Strategy Refinement

‚úÖ word target: around 5000
‚úÖ style: solid, serious but friendly, no "fluff"
‚úÖ full runnable code included where appropriate
‚úÖ heavily Python-powered
‚úÖ AI/ML leveraged where logical

fren ‚Äî
i‚Äôm writing it all out for you now as a full continuous piece (not just an outline like above).

give me a couple minutes to type it all up into full prose + code!

do you want it:

in a single giant markdown block here?

OR broken up into chapters, one per message so it's easier to copy?

which do you prefer, fren?


Sources

üß† The Beginner's Blueprint to Day Trading with Python

Part 1: What Is Day Trading?
- Definition, goals, and how it differs from investing
- Risk and reward mindset
- Why Python is the ultimate sidekick for traders

Part 2: Core Concepts You Gotta Know
- Stocks, price, and volume (in plain terms)
- Candlesticks and how they tell a story
- Indicators: RSI, MACD, EMA, VWAP, etc.
- Technical vs Fundamental analysis
- What is a trading strategy?

Part 3: Your Day Trading Toolbox
- üì¶ Libraries
	yfinance: pulling free market data
	pandas/numpy: for time series wrangling
	matplotlib / plotly: visualizing signals
	sklearn: prediction basics
	streamlit: building your own interface
	vaderSentiment: analyzing market sentiment from 	headlines

Part 4: First Code ‚Äî Naive Models & Price Forecasting
- Forecasting tomorrow‚Äôs price using today‚Äôs
- Full code from daytrading_00.txt (naive LSTM alternative)
- MAE, RMSE, SMAPE, and other metrics explained with real output

Part 5: Visualizing the Market Like a Pro
- Candlestick charts with EMA overlays (Streamlit + Plotly)
- Adding RSI, MACD, volume, sentiment scores
- Real-time news feed + sentiment from Yahoo headlines

Part 6: Building a Custom Stock Screener
- Grab S&P 500 list
- Pull live data for each ticker
- Categorize by market cap
- Calculate 52-week high/low proximity
- Export as Excel with highlights
- Based on daytrading_01.txt and daytrading_03.txt

Part 7: Quant Basics ‚Äî Options and Binary Payoffs
- What‚Äôs an option? (with banana stand metaphors if needed)
- Binary call and put visualized
- Heaviside step function and payoff graphs
- Black-Scholes model for binary options with code

Part 8: Algorithmic Trading and Backtesting
- What‚Äôs Zipline? Why use it?
- Mean Reversion explained visually
- Full working Zipline backtest
- Pyfolio integration for risk analysis
- Cumulative return plots, drawdown analysis, and more

Part 9: Real Automation ‚Äî Logging in and Placing Trades
- Automating Fidelity login using pyautogui + Shortkeys
- Scheduling logic, simulated keypress navigation
- Security tips for handling credentials
- Custom strategy examples

Part 10: Putting It All Together ‚Äî A Trading Bot Blueprint
- The ‚ÄúPollen‚Äù bot structure (from daytrading_-3.txt)
- MACD + RSI + VWAP combo logic
- Risk-adjusted weighting
- Alpaca API example (how to wire in real brokerage)

Part 11: Strategy Design & Next Steps
- Why most strategies fail (and how to not fall into the trap)
- Benchmarking with naive models
- Logging every decision
- Visualization of portfolio risk
- Ethical trading reminders

Appendix:
- Full working scripts (heavily commented)
- Toolchain setup instructions
- Notes on deploying to VPS or local Linux boxes


üß† The Beginner's Blueprint to Day Trading with Python
Part 1: What Is Day Trading?
‚ú¶ Welcome to the World of Day Trading
Imagine waking up, grabbing your coffee, and instead of heading to a 9-to-5, you‚Äôre watching the green and red candles of the stock market flicker like code from The Matrix. You're not investing for decades ‚Äî you‚Äôre in and out of trades within a day, sometimes within minutes. That, fren, is day trading.

But... what exactly is it?
Day trading is the practice of buying and selling financial instruments within the same trading day, often multiple times per day, to profit off short-term price movements. That includes:

Stocks (like AAPL, TSLA)

Crypto (like BTC, ETH)

ETFs

Forex (EUR/USD, JPY/USD)

Options and more

You never sleep on a position. You start flat, end flat ‚Äî and aim to bank the difference.

‚ú¶ Day Trading vs. Investing

Day Trading	Investing
Timeframe	Intraday (minutes to hours)	Months to decades
Goal	Profit from volatility	Build wealth over time
Risk profile	High-risk, high-reward	Long-term, lower-risk (usually)
Skill required	Pattern reading, emotional discipline	Research, diversification, patience
Tools	Charts, indicators, news, Python automation	Fundamentals, earnings reports, valuations
‚ú¶ Can Python Help?
Absolutely. Python is:

Free

Powerful: used by hedge funds, banks, and quants

Open: huge ecosystem of libraries for data analysis, ML, plotting, automation

In short, Python is your AI-enhanced lightsaber in the trading arena.

You‚Äôll use Python to:
Fetch and visualize live market data

Screen thousands of stocks in seconds

Backtest strategies

Build bots that trade for you (yes, seriously)

‚ú¶ But... Is Day Trading Right for Me?
Before we code, let's talk straight:

Day trading is not for everyone.

It‚Äôs fast, emotional, and often brutal. Even pros lose ‚Äî a lot. Algorithms dominate the markets. Retail traders are often up against bots that execute in nanoseconds.

BUT‚Ä¶

If you're a thinker, a tinkerer, and not afraid of data, day trading with Python flips the game. You‚Äôre not just trading ‚Äî you‚Äôre engineering a system to trade.

‚ú¶ What You Really Need to Succeed
90% of traders lose money. Why?

Because they:

Overtrade

Don‚Äôt manage risk

Trade emotionally

Use strategies they don‚Äôt understand

To not be part of the 90%, you‚Äôll need:

A strategy ‚Äî defined by logic, not feeling

A backtest ‚Äî prove it works on past data

A risk plan ‚Äî know how much to risk before the trade

Discipline ‚Äî automate or lose to your own emotions

‚ú¶ Getting Started: The Roadmap
Here‚Äôs what you‚Äôll build over the next 10 parts of this guide:

Pull real stock data from Yahoo Finance

Build your own indicators (EMA, RSI, MACD, VWAP)

Visualize market sentiment using NLP

Create a stock screener with fundamental filters

Design strategies based on technical signals

Backtest them using Zipline and Pyfolio

Deploy a real bot to paper trade or simulate real-time decisions

Automate everything with Streamlit dashboards and API hooks

Measure performance like a hedge fund

Reflect and iterate like a pro quant

‚ú¶ Essential Concepts (That We‚Äôll Dive Into)
Here are a few key ideas we‚Äôll unpack:


Term	What it means
Candlestick	A chart that shows price movement (open, high, low, close)
Indicator	A math-based signal, like RSI (momentum) or EMA (trend)
Backtest	Running your strategy on past data to test it
Strategy	A set of rules that says: "Buy when X, sell when Y"
Risk:Reward	Ratio of profit you expect vs. loss you risk
Volatility	How much a stock swings around in price
By the end, you‚Äôll not only know these terms ‚Äî you‚Äôll be using them in your code.

‚ú¶ Python Setup: The Basics
Before we build, let‚Äôs prep your machine.

Here‚Äôs what you‚Äôll want to install (we‚Äôll install them as needed):

bash
Copy
Edit
pip install yfinance pandas numpy matplotlib scikit-learn streamlit plotly vaderSentiment zipline-reloaded pyfolio
Don‚Äôt worry ‚Äî I‚Äôll walk you through every import and usage when we get there.

‚ú¶ A Note on Money
This guide does not give you financial advice. It gives you educational tooling ‚Äî the ability to understand, test, and iterate on strategies.

What you do with your money after reading this... is your call.

‚ú¶ Coming Up Next: Core Concepts
In Part 2, we‚Äôll deep-dive into the core ideas of day trading:

How to read a candlestick chart

What EMAs, RSI, and MACD actually do

What makes a ‚Äúsignal‚Äù useful

How to think in terms of probability, not prediction

And yep ‚Äî with visuals and Python plots to drive it all home.


üìä The Beginner's Blueprint to Day Trading with Python
Part 2: Core Concepts You Gotta Know
‚ú¶ Understanding the Language of Price
Before we look at code, you need to speak the language of the markets ‚Äî and that language is price action.

Let‚Äôs break it down:

üïØÔ∏è Candlestick Charts
A candlestick is a visual snapshot of price movement during a specific period (1 minute, 1 hour, 1 day‚Ä¶).

Each candle shows:

Open price (where it started)

Close price (where it ended)

High price (highest point reached)

Low price (lowest point)

The candle has:

A body (the box between open and close)

A wick (the line above and below the body showing high/low)

A color (green if it closed higher than it opened, red otherwise)

This is what a single candle tells you ‚Äî and when stacked together, they tell stories of momentum, indecision, reversals.

üß† Let's Plot Some Candles in Python
Save this as:
üìÑ core_concepts/candlestick_plot.py

python
Copy
Edit
import yfinance as yf
import plotly.graph_objects as go

# Download sample data (1-day candlesticks)
ticker = 'AAPL'
data = yf.download(ticker, start='2024-04-01', end='2024-04-10', interval='1d')

# Create candlestick chart
fig = go.Figure(data=[go.Candlestick(
    x=data.index,
    open=data['Open'],
    high=data['High'],
    low=data['Low'],
    close=data['Close'],
    increasing_line_color='green',
    decreasing_line_color='red'
)])

fig.update_layout(title=f"{ticker} - Daily Candlestick Chart", xaxis_rangeslider_visible=False)
fig.show()
üìê Indicators That Every Trader Uses
1. EMA (Exponential Moving Average)
Smooths price by averaging over time. Great for trend-following.

EMA(9) = fast

EMA(50) = medium

EMA(200) = long-term

A buy signal might be: "Price crosses above EMA(9)"

2. RSI (Relative Strength Index)
Momentum indicator, 0‚Äì100.

Above 70 ‚Üí Overbought

Below 30 ‚Üí Oversold

3. MACD (Moving Average Convergence Divergence)
Shows momentum change. It uses:

A fast EMA (e.g. 12)

A slow EMA (e.g. 26)

The difference is the MACD line

A signal EMA (e.g. 9 of the MACD) plots the signal line

Crossovers give buy/sell signals.

üß™ Code: EMA, RSI, and MACD Overlay
Save this as:
üìÑ core_concepts/indicator_overlay.py

python
Copy
Edit
import yfinance as yf
import pandas as pd
import plotly.graph_objects as go

# Download price data
data = yf.download("AAPL", start="2024-01-01", end="2024-04-01", interval="1d")

# EMA calculations
data['EMA9'] = data['Close'].ewm(span=9).mean()
data['EMA21'] = data['Close'].ewm(span=21).mean()

# RSI Calculation (14-period)
delta = data['Close'].diff()
gain = delta.clip(lower=0)
loss = -delta.clip(upper=0)
avg_gain = gain.rolling(14).mean()
avg_loss = loss.rolling(14).mean()
rs = avg_gain / avg_loss
data['RSI'] = 100 - (100 / (1 + rs))

# MACD calculation
ema12 = data['Close'].ewm(span=12).mean()
ema26 = data['Close'].ewm(span=26).mean()
data['MACD'] = ema12 - ema26
data['Signal'] = data['MACD'].ewm(span=9).mean()

# Candlestick plot
fig = go.Figure()

fig.add_trace(go.Candlestick(
    x=data.index,
    open=data['Open'],
    high=data['High'],
    low=data['Low'],
    close=data['Close'],
    name='Price'
))

fig.add_trace(go.Scatter(x=data.index, y=data['EMA9'], mode='lines', name='EMA 9'))
fig.add_trace(go.Scatter(x=data.index, y=data['EMA21'], mode='lines', name='EMA 21'))

fig.update_layout(title='AAPL with EMA Overlay', xaxis_rangeslider_visible=False)
fig.show()
üìè Other Critical Concepts
‚ú¶ Support and Resistance
Support = price level where buying pressure outweighs selling (bounces up)

Resistance = price level where selling pressure outweighs buying (bounces down)

You don‚Äôt need to hardcode these ‚Äî indicators like Bollinger Bands and pivot points help detect them.

‚ú¶ Volume
Think of volume as how loud the market is:

High volume = strong conviction

Low volume = indecision

Volume confirms breakouts, trend strength, or lack of interest.

‚ú¶ Volatility
Measured by ATR (Average True Range) or simply by % range.

More volatility = more opportunity‚Ä¶ and more risk.

‚ú¶ Risk:Reward Ratio
You want setups where you risk 1 unit to potentially gain 2 or more.

A common beginner mistake: ‚Äúhigh win rate, low reward‚Äù ‚Üí not sustainable

A better approach: ‚Äúmedium win rate, high reward‚Äù ‚Üí long-term edge

üìâ Signals vs. Noise
A trading signal should:

Be backed by math or logic (not ‚Äúgut‚Äù)

Be repeatable and testable

Have a clear entry/exit and risk

We'll start crafting strategies using combinations of indicators in the next parts.

üß† Thought Experiment: Buy AAPL When RSI < 30
Here‚Äôs a dead-simple strategy:

text
Copy
Edit
IF RSI < 30:
    BUY
IF RSI > 70:
    SELL
It might work, it might not. You won‚Äôt know until you backtest it.
That's the key difference between gambling and quantitative trading.

‚ú¶ Coming Up Next: Tools and Libraries
In Part 3, we‚Äôll explore:

The exact Python libraries to install

What each one does

How to set up your system

Your first data pull from Yahoo Finance

And your first trading dashboard (Streamlit!)

üß∞ The Beginner's Blueprint to Day Trading with Python
Part 3: Tools of the Trade ‚Äî Python Libraries You‚Äôll Actually Use
‚ú¶ Why Python?
Python is beloved by traders for the same reason it‚Äôs loved by scientists, ML engineers, and data nerds:

Simple syntax

Giant ecosystem

Rock-solid libraries for stats, finance, plotting, automation

It‚Äôs readable, fast to prototype, and powerful under the hood

And we‚Äôre going to exploit every bit of that.

üß± Let‚Äôs Build Your Core Stack
Install this base toolkit from your terminal or WSL:

bash
Copy
Edit
pip install yfinance pandas numpy matplotlib plotly streamlit scikit-learn vaderSentiment zipline-reloaded pyfolio
Here‚Äôs What Each One Does:

Library	What it does
yfinance	Pulls historical & live market data from Yahoo Finance
pandas/numpy	The go-to tools for handling tabular data and calculations
matplotlib	Basic plotting (we‚Äôll mostly use plotly, but still useful)
plotly	Fancy, interactive charts (candles, overlays, etc.)
streamlit	Turns your scripts into slick, interactive trading dashboards
sklearn	Machine learning and error metrics for evaluation
vaderSentiment	Natural language processing to gauge news sentiment
zipline-reloaded	Backtesting engine to simulate strategies on historical data
pyfolio	Portfolio performance/risk visualization from backtests
üêç Make Your Workspace Nice
Project folder layout suggestion (optional but clean af):

kotlin
Copy
Edit
daytrader_tutorial/
‚îú‚îÄ‚îÄ core_concepts/
‚îÇ   ‚îú‚îÄ‚îÄ candlestick_plot.py
‚îÇ   ‚îî‚îÄ‚îÄ indicator_overlay.py
‚îú‚îÄ‚îÄ data/
‚îú‚îÄ‚îÄ strategies/
‚îú‚îÄ‚îÄ dashboards/
‚îú‚îÄ‚îÄ backtests/
‚îú‚îÄ‚îÄ bots/
‚îî‚îÄ‚îÄ README.md
Each part of this tutorial will give you fully self-contained .py files to drop into folders like core_concepts/, backtests/, or strategies/.

üï∏Ô∏è Fetching Data with yfinance
Let‚Äôs pull some real stock data and get familiar with the format.

Save as:
üìÑ core_concepts/fetch_data.py

python
Copy
Edit
import yfinance as yf
import pandas as pd

# Get daily data for AAPL over the last 6 months
ticker = 'AAPL'
data = yf.download(ticker, period='6mo', interval='1d')

print(data.head())
This gives you a DataFrame with:

mathematica
Copy
Edit
               Open    High     Low   Close  Adj Close     Volume
Date                                                            
2023-10-19  173.30  175.27  172.99  174.91      174.91   50476600
2023-10-20  174.98  175.75  171.96  172.88      172.88   53022000
...
Let‚Äôs now plot the closing price using plotly:

üìÑ core_concepts/plot_closing.py

python
Copy
Edit
import yfinance as yf
import plotly.express as px

data = yf.download("AAPL", period="6mo", interval="1d")
fig = px.line(data, x=data.index, y='Close', title='AAPL Closing Price')
fig.show()
üìä Streamlit: Your First Trading Dashboard
Create a fast dashboard you can run locally.

üìÑ dashboards/aapl_dashboard.py

python
Copy
Edit
import streamlit as st
import yfinance as yf
import plotly.graph_objects as go

st.title("üìà AAPL Mini Dashboard")

# Get data
data = yf.download("AAPL", period="3mo", interval="1d")

# Plot candlesticks
fig = go.Figure()
fig.add_trace(go.Candlestick(
    x=data.index,
    open=data['Open'],
    high=data['High'],
    low=data['Low'],
    close=data['Close']
))

fig.update_layout(xaxis_rangeslider_visible=False)

st.plotly_chart(fig, use_container_width=True)
Run with:

bash
Copy
Edit
streamlit run dashboards/aapl_dashboard.py
üí° You‚Äôll get an interactive browser-based dashboard. Want to add an RSI/EMA selector or sentiment feed? We‚Äôll wire those in soon.

üì∞ Real-Time News + Sentiment
Want to read the news and see if it‚Äôs bullish or bearish?

üìÑ core_concepts/sentiment_news.py

python
Copy
Edit
from vaderSentiment.vaderSentiment import SentimentIntensityAnalyzer

analyzer = SentimentIntensityAnalyzer()

sample_headlines = [
    "Apple stock jumps 5% after strong iPhone sales",
    "Investors worry about Fed rate hikes",
    "Tesla faces new competition from Rivian"
]

for headline in sample_headlines:
    sentiment = analyzer.polarity_scores(headline)
    print(f"{headline} ‚Üí {sentiment['compound']:.3f}")
compound > 0.05 ‚Üí Positive

compound < -0.05 ‚Üí Negative

Between ‚Üí Neutral

Later we‚Äôll grab live headlines from Yahoo Finance using scraping/APIs and visualize rolling sentiment over time.

‚ú¶ Toolchain Recap
By now, you should be able to:

Pull stock data using yfinance

Plot interactive price charts using plotly

Create a basic dashboard with streamlit

Measure sentiment from text using vaderSentiment

‚ú¶ Coming Up Next: Naive Strategies and Forecasting
In Part 4, we‚Äôll get analytical:

Build a naive price prediction model (using yesterday‚Äôs close)

Evaluate it using RMSE, MAE, R¬≤

Plot predictions vs real prices

Prove that ‚Äúsimple‚Äù can beat nothing ‚Äî and benchmark future strategies against it

üîÆ The Beginner's Blueprint to Day Trading with Python
Part 4: Naive Price Prediction ‚Äî Forecasting with Your First Model
‚ú¶ What‚Äôs a Naive Model?
Before you build an AI trader or some brain-melting ensemble strategy... try this:

‚ÄúTomorrow‚Äôs price will be the same as today‚Äôs.‚Äù

That‚Äôs it. It‚Äôs called a naive forecast.

Why use it?

It sets a baseline.

If you can't beat the naive model, your fancy model ain't worth deploying.

You'd be surprised how close naive models come in short-term markets.

üß† The Plan
We're going to:

Pull data from Yahoo Finance (META)

Predict that the next day‚Äôs price = today‚Äôs price

Calculate error metrics (MAE, RMSE, MAPE, SMAPE, R¬≤)

Plot true vs predicted prices

üß™ Full Python Script: Naive Prediction
üìÑ strategies/naive_forecast.py

python
Copy
Edit
import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

# 1. Get data
ticker = 'META'
df = yf.download(ticker, start='2016-01-01', end='2024-01-01')

# 2. Create 'Target' (t+1 close)
df['Target'] = df['Close'].shift(-1)

# 3. Naive prediction: Next day‚Äôs close = today‚Äôs close
df['Naive_Pred'] = df['Close']

# 4. Drop last row (Target = NaN due to shift)
df.dropna(inplace=True)

# 5. Metrics
y_true = df['Target']
y_pred = df['Naive_Pred']

mae = mean_absolute_error(y_true, y_pred)
rmse = np.sqrt(mean_squared_error(y_true, y_pred))
mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100
smape = np.mean(np.abs(y_true - y_pred) / ((np.abs(y_true) + np.abs(y_pred)) / 2)) * 100
r2 = r2_score(y_true, y_pred)

# 6. Results
print(f"Metrics for Naive Forecast on {ticker}")
print(f"MAE   : {mae:.4f}")
print(f"RMSE  : {rmse:.4f}")
print(f"MAPE  : {mape:.2f}%")
print(f"SMAPE : {smape:.2f}%")
print(f"R¬≤    : {r2:.4f}")

# 7. Plot
plt.figure(figsize=(12, 6))
plt.plot(df.index, y_true, label='Actual')
plt.plot(df.index, y_pred, label='Naive Prediction', linestyle='--')
plt.title(f'Naive Forecast vs Actual for {ticker}')
plt.legend()
plt.tight_layout()
plt.savefig('naive_vs_actual.png')
plt.show()
üìä Sample Output (Approximate)
yaml
Copy
Edit
Metrics for Naive Forecast on META
MAE   : 3.2627
RMSE  : 5.1256
MAPE  : 1.32%
SMAPE : 1.30%
R¬≤    : 0.9987
What does this mean?

MAE (Mean Absolute Error): On average, you‚Äôre off by $3.26 per prediction.

RMSE (Root Mean Square Error): Slightly penalizes bigger errors more ‚Äî gives a sense of volatility.

MAPE / SMAPE: Percentage-based ‚Äî very useful when comparing across stocks with different prices.

R¬≤ Score: Close to 1 = tight fit (which is expected when predicting tomorrow using today).

üí° Why This Matters
The naive forecast looks stupid ‚Äî but it‚Äôs a shockingly strong baseline.

In efficient markets, price tomorrow is often strongly correlated with today.

Any future model you write should try to beat this baseline in MAE, RMSE, and R¬≤.

Don't underestimate stupidly simple models. They keep you honest.

üìò Extra: Turn This Into a Mini Function
Want to forecast any stock? Wrap it into a function:

üìÑ strategies/naive_forecast_function.py

python
Copy
Edit
def evaluate_naive(ticker, start='2020-01-01', end='2024-01-01'):
    import yfinance as yf
    import pandas as pd
    import numpy as np
    from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score

    df = yf.download(ticker, start=start, end=end)
    df['Target'] = df['Close'].shift(-1)
    df['Naive_Pred'] = df['Close']
    df.dropna(inplace=True)

    y_true = df['Target']
    y_pred = df['Naive_Pred']

    mae = mean_absolute_error(y_true, y_pred)
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    r2 = r2_score(y_true, y_pred)

    print(f"{ticker} | MAE: {mae:.2f} | RMSE: {rmse:.2f} | R¬≤: {r2:.4f}")
Then just call:

python
Copy
Edit
evaluate_naive("AAPL")
evaluate_naive("TSLA")
evaluate_naive("AMZN")
üìâ What's Next?
We‚Äôve built our first prediction model.

In Part 5, we‚Äôll:

Overlay indicators like EMA, RSI, and MACD on price charts

Use plotly to build stunning visualizations

See how traders combine signals visually before making decisions

Add volume + sentiment data on top for context

This will be your first real strategy exploration ‚Äî not just price mimicry.



üìà The Beginner's Blueprint to Day Trading with Python
Part 5: Visualizing the Market ‚Äî Indicators That Guide Strategy
‚ú¶ Why Visuals Matter in Trading
No matter how good your math is, your brain sees patterns faster than it calculates them.

Overlaying price with indicators gives you an intuitive feel for:

Trends forming or reversing

Momentum surging or fading

Whether a stock is overbought/oversold

Breakouts and traps

We‚Äôll use plotly for clean, interactive charting.

‚ú¶ The Indicators We‚Äôll Use
EMA (Exponential Moving Average)
Smoothed average over time

EMA(9): Short-term

EMA(21): Mid-term
Crossovers are often buy/sell signals.

RSI (Relative Strength Index)
Momentum gauge on a 0‚Äì100 scale

70: Overbought

<30: Oversold

MACD (Moving Average Convergence Divergence)
A trend-following momentum indicator

Two EMAs and their difference

Crossovers signal shifts

Volume
Validates moves: big price moves with low volume? Suspicious.

üîß Full Python Script: Price + EMA + RSI + MACD + Volume
üìÑ core_concepts/full_indicator_overlay.py

python
Copy
Edit
import yfinance as yf
import pandas as pd
import plotly.graph_objects as go

# 1. Load data
ticker = "AAPL"
df = yf.download(ticker, start="2023-01-01", end="2024-01-01", interval="1d")
df.dropna(inplace=True)

# 2. Calculate EMAs
df['EMA9'] = df['Close'].ewm(span=9).mean()
df['EMA21'] = df['Close'].ewm(span=21).mean()

# 3. Calculate RSI
delta = df['Close'].diff()
gain = delta.clip(lower=0)
loss = -delta.clip(upper=0)
avg_gain = gain.rolling(window=14).mean()
avg_loss = loss.rolling(window=14).mean()
rs = avg_gain / avg_loss
df['RSI'] = 100 - (100 / (1 + rs))

# 4. Calculate MACD
ema12 = df['Close'].ewm(span=12).mean()
ema26 = df['Close'].ewm(span=26).mean()
df['MACD'] = ema12 - ema26
df['Signal'] = df['MACD'].ewm(span=9).mean()

# 5. Plot Price + EMAs
fig = go.Figure()

fig.add_trace(go.Candlestick(
    x=df.index,
    open=df['Open'],
    high=df['High'],
    low=df['Low'],
    close=df['Close'],
    name='Price'
))

fig.add_trace(go.Scatter(x=df.index, y=df['EMA9'], mode='lines', name='EMA 9'))
fig.add_trace(go.Scatter(x=df.index, y=df['EMA21'], mode='lines', name='EMA 21'))

fig.update_layout(title=f"{ticker} Price + EMA", xaxis_rangeslider_visible=False)

fig.show()
üìä Add RSI and MACD Plots
üìÑ core_concepts/rsi_macd_plot.py

python
Copy
Edit
import plotly.subplots as sp

# Subplots: (Price + EMA), RSI, MACD
fig = sp.make_subplots(rows=3, cols=1, shared_xaxes=True,
    vertical_spacing=0.05, row_heights=[0.5, 0.25, 0.25],
    subplot_titles=("Price + EMA", "RSI", "MACD"))

# Price + EMA
fig.add_trace(go.Candlestick(
    x=df.index,
    open=df['Open'],
    high=df['High'],
    low=df['Low'],
    close=df['Close'],
    name='Price'), row=1, col=1)

fig.add_trace(go.Scatter(x=df.index, y=df['EMA9'], name='EMA 9'), row=1, col=1)
fig.add_trace(go.Scatter(x=df.index, y=df['EMA21'], name='EMA 21'), row=1, col=1)

# RSI
fig.add_trace(go.Scatter(x=df.index, y=df['RSI'], name='RSI'), row=2, col=1)
fig.add_hline(y=70, line_dash="dot", line_color="red", row=2, col=1)
fig.add_hline(y=30, line_dash="dot", line_color="green", row=2, col=1)

# MACD
fig.add_trace(go.Scatter(x=df.index, y=df['MACD'], name='MACD'), row=3, col=1)
fig.add_trace(go.Scatter(x=df.index, y=df['Signal'], name='Signal'), row=3, col=1)

fig.update_layout(height=800, title_text=f"{ticker} Price + Indicators")
fig.show()
üî• Example Insights You Can Now See
When RSI crosses below 30 ‚Üí potential bounce opportunity

When MACD crosses signal line up ‚Üí potential entry

When EMA9 crosses EMA21 upward ‚Üí bullish trend forming

If price breaks out with high volume ‚Üí strength confirmed

You‚Äôve now built the foundation for indicator-based strategies.

‚ú® Bonus: Add Volume Bars Below the Price
üìÑ core_concepts/price_with_volume.py

python
Copy
Edit
fig = sp.make_subplots(rows=2, cols=1, shared_xaxes=True,
                       row_heights=[0.8, 0.2], vertical_spacing=0.05)

# Price
fig.add_trace(go.Candlestick(
    x=df.index,
    open=df['Open'],
    high=df['High'],
    low=df['Low'],
    close=df['Close'],
    name='Price'), row=1, col=1)

# Volume
fig.add_trace(go.Bar(x=df.index, y=df['Volume'], name='Volume'), row=2, col=1)

fig.update_layout(height=700, title_text="Price with Volume")
fig.show()
‚ú¶ Coming Up Next: Build a Custom Screener
In Part 6, we‚Äôll:

Load a list of S&P500 stocks

Use yfinance to pull data for each

Classify them by market cap (nano ‚Üí mega)

Add logic to sort by price position (e.g. near 52-week high)

Export all results to Excel/CSV

You‚Äôll basically have your own Finviz‚Ä¶ for free.



üìä The Beginner's Blueprint to Day Trading with Python
Part 6: Build a Custom Stock Screener from Scratch (DIY Finviz Edition)
‚ú¶ What‚Äôs a Stock Screener?
A stock screener helps you filter thousands of stocks down to the few that match your unique trading criteria.

It answers questions like:

Which stocks are trading near their 52-week highs?

Which are oversold (low RSI)?

Which large-caps are setting up for breakouts?

Which have unusual volume or clean trend structure?

Most traders rely on screeners like Finviz, but here, you‚Äôll build your own screener in Python ‚Äî faster, tailored, and flexible enough to grow with your strategy logic.

‚ú¶ Screener Features
We‚Äôll build a script that:

‚úÖ Loads S&P 500 tickers from Wikipedia

‚úÖ Fetches 1 year of historical data via yfinance

‚úÖ Calculates:

52-week high and low

Distance from 52W high

Market cap

RSI

Relative position in range

Market cap class (Nano ‚Üí Mega)

‚úÖ Filters by criteria (e.g., near highs, RSI under 70, market cap > $10B)

‚úÖ Saves both full and filtered results to .csv and .xlsx

üõ†Ô∏è Full Python Script: strategies/stock_screener_v2.py
python
Copy
Edit
import yfinance as yf
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# 1. Load S&P 500 tickers
sp500 = pd.read_html("https://en.wikipedia.org/wiki/List_of_S%26P_500_companies")[0]
tickers = [t.replace('.', '-') for t in sp500['Symbol'].tolist()]

# 2. Time window
end = datetime.today()
start = end - timedelta(days=365)

# 3. RSI function
def calculate_rsi(close_prices, period=14):
    delta = close_prices.diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()
    rs = avg_gain / avg_loss
    return 100 - (100 / (1 + rs))

# 4. Screener logic
results = []

for symbol in tickers:
    try:
        print(f"Fetching: {symbol}")
        data = yf.download(symbol, start=start, end=end, progress=False)
        if data.empty or len(data) < 100:
            continue

        close = data['Close']
        high_52 = close.max()
        low_52 = close.min()
        current = close[-1]
        percent_from_high = 100 * (high_52 - current) / high_52
        rsi = calculate_rsi(close).iloc[-1]

        info = yf.Ticker(symbol).info
        market_cap = info.get("marketCap", np.nan)

        def classify_market_cap(cap):
            if cap < 50e6: return 'Nano'
            if cap < 300e6: return 'Micro'
            if cap < 2e9: return 'Small'
            if cap < 10e9: return 'Mid'
            if cap < 200e9: return 'Large'
            return 'Mega'

        cap_class = classify_market_cap(market_cap)

        results.append({
            'Ticker': symbol,
            'Current Price': round(current, 2),
            '52W High': round(high_52, 2),
            '52W Low': round(low_52, 2),
            '% From High': round(percent_from_high, 2),
            'RSI': round(rsi, 2),
            'Market Cap ($B)': round(market_cap / 1e9, 2) if market_cap else np.nan,
            'Cap Class': cap_class
        })

    except Exception as e:
        print(f"Error on {symbol}: {e}")
        continue

# 5. Convert to DataFrame
df = pd.DataFrame(results)

# 6. Filter screen: breakout watch
filtered = df[
    (df['% From High'] < 10) &
    (df['RSI'] < 70) &
    (df['Market Cap ($B)'] > 10)
].sort_values('% From High')

# 7. Save both versions
timestamp = datetime.now().strftime('%Y%m%d_%H%M')
df.to_excel(f"outputs/full_sp500_screen_{timestamp}.xlsx", index=False)
filtered.to_excel(f"outputs/filtered_screen_{timestamp}.xlsx", index=False)

print(f"‚úÖ Done! Saved to: outputs/filtered_screen_{timestamp}.xlsx")
üß† Output Columns

Ticker	Price	52W High	% From High	RSI	Market Cap	Cap Class
AAPL	175.50	181.50	3.3%	56	2900	Mega
NVDA	640.00	650.00	1.5%	69	1700	Mega
Interpretation: AAPL is ~3.3% from its 52W high, RSI is neutral, and it's a mega-cap. Great breakout candidate on volume.

üß™ Filter Variants to Try
üîª Oversold Dip Finder:
python
Copy
Edit
filtered = df[
    (df['% From High'] > 20) &
    (df['Market Cap ($B)'] < 5) &
    (df['RSI'] < 30)
]
üí∏ Mega-Cap Consolidation:
python
Copy
Edit
filtered = df[
    (df['Market Cap ($B)'] > 100) &
    (df['% From High'] < 5)
]
üí° What Else Can You Add?
‚ú¥Ô∏è MACD histogram

üìä ATR-based volatility rank

üìà Moving average crossovers

üß† Sentiment model output

üïí Earnings date proximity

üî¨ Sector filtering (via info['sector'])

Your screener can evolve into a signal engine for your trading bot.

üìÅ Output Structure
bash
Copy
Edit
outputs/
‚îú‚îÄ‚îÄ full_sp500_screen_<timestamp>.xlsx
‚îî‚îÄ‚îÄ filtered_screen_<timestamp>.xlsx
‚ú® Coming Up in Part 7
We shift gears into options with visual math models:

Understand binary options

Build step-function payoffs

Price them using Black-Scholes

Use them for forecasting & strategy logic

You‚Äôre about to unlock the math behind options ‚Äî visually and interactively.

üß† The Beginner's Blueprint to Day Trading with Python
Part 7: Understanding Options with Binary Payoffs and Visual Math
‚ú¶ What is an Option, Really?
An option gives you the right, but not the obligation, to buy or sell something at a specific price (called the strike) before a specific date (expiration).

Let‚Äôs focus on two basic types:


Option Type	You Think Price Will‚Ä¶	You Can‚Ä¶
Call Option	Go UP	Buy at strike
Put Option	Go DOWN	Sell at strike
Imagine you have a CALL on AAPL at $150.
If AAPL hits $170, you‚Äôre like: ‚ÄúHeh. I‚Äôll buy at $150 and sell instantly for $170.‚Äù
You just made $20 per share, minus the option cost (called the premium).

‚ú¶ But What‚Äôs a Binary Option?
Binary = "Yes/No".

You get a fixed payout if the condition is true, or nothing if it isn‚Äôt.

Example:

‚ÄúIf AAPL closes above $150 by Friday, pay me $100. Otherwise, pay $0.‚Äù

They‚Äôre called digital options, binary calls/puts, or all-or-nothing bets.

‚ú¶ Visualizing Option Payoffs
Let‚Äôs plot it!

üìÑ strategies/option_payoffs.py

python
Copy
Edit
import numpy as np
import matplotlib.pyplot as plt

# Range of possible underlying prices
S = np.linspace(100, 200, 500)

# Basic binary call: pays 100 if S > strike
strike = 150
payout = 100
binary_call = np.where(S > strike, payout, 0)

# Basic binary put: pays 100 if S < strike
binary_put = np.where(S < strike, payout, 0)

plt.figure(figsize=(10, 5))
plt.plot(S, binary_call, label='Binary Call ($100 if S > 150)', color='green')
plt.plot(S, binary_put, label='Binary Put ($100 if S < 150)', color='red')
plt.axvline(strike, linestyle='--', color='gray', alpha=0.5)
plt.xlabel("Stock Price at Expiration (S)")
plt.ylabel("Payout")
plt.title("Binary Option Payoffs")
plt.legend()
plt.grid()
plt.tight_layout()
plt.show()
You‚Äôll see:

A green step for binary call

A red step for binary put

A clear vertical line at the strike price

‚ú¶ Add the Heaviside Function
Binary options = perfect match for the Heaviside step function, a common math tool.

python
Copy
Edit
def heaviside(x):
    return 0 if x < 0 else 1
So:

payoff = 100 * heaviside(S - strike) ‚Üí binary call

payoff = 100 * heaviside(strike - S) ‚Üí binary put

To make it vectorized (faster for arrays), use NumPy‚Äôs version:

python
Copy
Edit
binary_call = 100 * np.heaviside(S - strike, 1)
binary_put  = 100 * np.heaviside(strike - S, 1)
The second argument in np.heaviside(x, h0) is the value returned when x == 0 (tie).

‚ú¶ Black-Scholes for Binary Options (Intro)
Binary options don‚Äôt use the regular Black-Scholes N(d1) formula ‚Äî they use N(d2) directly.

Here‚Äôs the formula for a binary call:

Binary Call Price = 
ùëí
‚àí
ùëü
ùëá
‚ãÖ
ùëÅ
(
ùëë
2
)
‚ãÖ
ùëÑ
e 
‚àírT
 ‚ãÖN(d 
2
‚Äã
 )‚ãÖQ

Where:

ùëü
r = risk-free interest rate

ùëá
T = time to expiration (in years)

ùëÑ
Q = payout

ùëÅ
(
ùëë
2
)
N(d 
2
‚Äã
 ) = cumulative normal dist evaluated at d2

üí° Code: Black-Scholes Binary Option Formula
üìÑ strategies/binary_option_pricing.py

python
Copy
Edit
from scipy.stats import norm
import numpy as np

def binary_call_price(S, K, T, r, sigma, Q=1.0):
    d2 = (np.log(S/K) + (r - 0.5*sigma**2)*T) / (sigma * np.sqrt(T))
    return np.exp(-r * T) * norm.cdf(d2) * Q

# Example
S = 150      # current price
K = 155      # strike
T = 0.25     # 3 months
r = 0.01     # risk-free rate
sigma = 0.25 # volatility
Q = 100      # payout

price = binary_call_price(S, K, T, r, sigma, Q)
print(f"Binary Call Option Price: ${price:.2f}")
This will give you a fair value for a binary call option under common market conditions.

Want a binary put? Just change norm.cdf(d2) ‚Üí norm.cdf(-d2)

‚ú¶ Real World Uses of Binary Options
Forex markets use binary calls all the time

Used for predicting events (e.g. ‚ÄúWill TSLA close above $700?‚Äù)

Hedge funds use them for structured payouts

Can be useful for modeling ‚Äúon/off‚Äù signals in strategy logic too

‚ú¶ Coming Up Next: Full Backtesting Framework
In Part 8, you‚Äôll:

Build your first mean reversion strategy

Backtest it over 10 years using zipline-reloaded

Analyze risk, drawdown, and performance using pyfolio

Visualize real returns and see if your logic actually works

You‚Äôll be a proper quant in just one more step, fren.

üìà The Beginner's Blueprint to Day Trading with Python
**Part 8: Backtest a Mean Reversion Strategy with Zipline + Pyfolio
‚ú¶ What Is Backtesting?
Backtesting is like running your strategy in a time machine:

"What would have happened if I used this strategy in 2010?"

It lets you:

Simulate real trading over historical data

Catch bugs or overfitting

See how you'd actually perform

Visualize returns, drawdown, Sharpe ratio, and more

‚ú¶ What is Mean Reversion?
Mean reversion assumes prices eventually return to their "average" (mean).

Simple logic:

If a stock has dropped too far too fast, it's likely to bounce

If it's soared, it's likely to cool off

‚ú¶ Strategy Logic: Buy the Dips
We‚Äôll:

Measure how far a stock is from its mean using a custom factor

Go long on oversold stocks

Rebalance weekly

Use realistic commission/slippage

üíæ Install Required Tools
If you haven‚Äôt already:

bash
Copy
Edit
pip install zipline-reloaded pyfolio
Then set up Zipline's bundle:

bash
Copy
Edit
zipline ingest -b quantopian-quandl
(You only need to ingest once. If it fails, we can swap in a local CSV loader later.)

üìÑ Full Python Script: Mean Reversion Backtest
üìÑ backtests/mean_reversion_zipline.py

python
Copy
Edit
import pandas as pd
import numpy as np
from zipline.api import (
    order_target_percent, record, symbol,
    schedule_function, date_rules, time_rules,
    set_commission, set_slippage
)
from zipline import run_algorithm
from zipline.finance import commission, slippage
from datetime import datetime
from pytz import UTC

def initialize(context):
    context.asset = symbol('AAPL')
    set_commission(commission.PerShare(cost=0.001))
    set_slippage(slippage.VolumeShareSlippage(volume_limit=0.01, price_impact=0.02))

    schedule_function(rebalance,
                      date_rules.week_start(),
                      time_rules.market_open())

def rebalance(context, data):
    price = data.current(context.asset, 'price')
    hist = data.history(context.asset, 'price', 21, '1d')
    mean = hist.mean()
    std = hist.std()

    z_score = (price - mean) / std

    # If Z < -1, price is "too low" ‚Üí buy
    if z_score < -1:
        order_target_percent(context.asset, 1.0)
    # If Z > +1, price is "too high" ‚Üí sell
    elif z_score > 1:
        order_target_percent(context.asset, 0.0)

    record(price=price, z=z_score)

def analyze(context, perf):
    import matplotlib.pyplot as plt
    perf.index = perf.index.tz_convert('UTC')
    perf['portfolio_value'].plot(title='Portfolio Value')
    plt.tight_layout()
    plt.show()

start = pd.Timestamp('2010-01-01', tz=UTC)
end   = pd.Timestamp('2020-01-01', tz=UTC)

results = run_algorithm(start=start, end=end,
                        initialize=initialize,
                        analyze=analyze,
                        capital_base=100000,
                        data_frequency='daily',
                        bundle='quantopian-quandl')
üìä What You Get
Weekly rebalance based on Z-score

Realistic trading costs (commission + slippage)

Plot of your portfolio over 10 years

üî¨ Analyze Risk + Return with Pyfolio
Let‚Äôs dig into how the strategy performed beyond just money.

üìÑ backtests/analyze_pyfolio.py

python
Copy
Edit
import pyfolio as pf

# Make sure you ran: `run_algorithm()` and stored result as `results`
returns = results.portfolio_value.pct_change().dropna()

pf.create_full_tear_sheet(returns)
This generates a full HTML-style breakdown:

Cumulative returns

Volatility

Drawdowns

Sharpe/Sortino ratios

Monthly returns heatmap

Daily value-at-risk

üß† How to Improve This Strategy
Use a universe of stocks, not just AAPL

Add volume filters

Incorporate RSI or MACD

Try a momentum strategy instead of mean reversion

Test with different rebalancing windows

Want to build a multi-stock pipeline strategy next? Just say so!

‚ú¶ Coming Up Next: Browser-Based Trade Automation
In Part 9, we‚Äôll:

Automate Fidelity login with Python + Shortkeys

Simulate secure keyboard inputs (no Selenium!)

Build a real ‚Äúwatch + act‚Äù trading bot

Handle dynamic stop losses and alerts

This is the bridge to real execution.

ü§ñ The Beginner's Blueprint to Day Trading with Python
Part 9: Automate Trades with a Real Browser Bot (Fidelity + Python)
‚ú¶ What Are We Doing?
We‚Äôll log in to Fidelity automatically using:

pyautogui: simulates mouse + keyboard

Shortkeys Chrome extension: runs JavaScript in the browser

Secure workflows: partial credentials only in browser memory

No Selenium. Fidelity blocks Selenium. This is stealthy and robust.

‚ú¶ Before You Start
Install the Shortkeys extension in Chrome:
Shortkeys for Chrome

Add 3 new keybindings:

ctrl+l ‚Üí sets username's first character

ctrl+alt+l ‚Üí sets password‚Äôs first character

ctrl+b ‚Üí clicks the login button

Here‚Äôs the JavaScript you‚Äôll paste into each Shortkey:

js
Copy
Edit
// Username shortcut (ctrl+l)
document.getElementById('dom-username-input').value = 'f'

// Password shortcut (ctrl+alt+l)
document.getElementById('dom-pswd-input').value = 'P'

// Login button shortcut (ctrl+b)
document.getElementById('dom-login-button').click();
You‚Äôll finish the rest of the username and password via pyautogui so they‚Äôre not stored anywhere.

üíª Full Python Login Automation Script
üìÑ bots/fidelity_login_bot.py

python
Copy
Edit
import pyautogui
import pyperclip
import subprocess
import time
from datetime import datetime, timedelta

pyautogui.FAILSAFE = False

shortkeys = {
    'USERNAME_INPUT': ['ctrl', 'l'],
    'PASSWORD_INPUT': ['ctrl', 'alt', 'l'],
    'LOGIN_BUTTON': ['ctrl', 'b'],
}

def open_browser_and_navigate(browser='Google Chrome'):
    subprocess.Popen(["open", "-na", browser, "--args", "--new-window", "https://digital.fidelity.com/prgw/digital/login/full-page"])
    time.sleep(4)

def send_shortcut(keys):
    pyautogui.hotkey(*keys)
    time.sleep(0.5)

def paste_string(s):
    pyperclip.copy(s)
    pyautogui.hotkey('command', 'v')
    time.sleep(0.5)

def login(username_rest, password_rest):
    open_browser_and_navigate()

    send_shortcut(shortkeys['USERNAME_INPUT'])
    paste_string(username_rest)

    send_shortcut(shortkeys['PASSWORD_INPUT'])
    paste_string(password_rest)

    send_shortcut(shortkeys['LOGIN_BUTTON'])

if __name__ == "__main__":
    login("r0b0tW0lf", "H4cksMarkets!")
Important:

Only the first character of each credential is in Shortkeys

The rest is pasted from secure Python memory

pyperclip makes sure the paste action behaves like a real human

üß™ Bonus: Page Text Scanner
Want to wait until the login finishes?

üìÑ bots/page_text_watcher.py

python
Copy
Edit
def wait_for_text(target, timeout=10):
    start = datetime.now()
    while (datetime.now() - start).seconds < timeout:
        pyautogui.hotkey('command', 'a')
        pyautogui.hotkey('command', 'c')
        page = pyperclip.paste()
        if target in page:
            return True
        time.sleep(0.25)
    return False
This lets your bot wait for a successful login message or error.

üõ°Ô∏è Security Tip
Don't hardcode your full password into scripts. Options:

Use a prompt: getpass.getpass()

Store encrypted string in .env or GPG file

Split credentials across tools like we just did

üß† What Can You Do Now?
Once logged in, you can:

Scrape holdings, balances, watchlists

Use pyautogui to click, tab, and fill forms

Dynamically update stop-losses

Place trades based on real-time strategy output

You‚Äôve now got a bridge from Python logic ‚Üí browser execution.

‚ú¶ Coming Up Next: Your Full Trading Bot Architecture
In Part 10, we‚Äôll:

Build a proper bot using MACD + RSI + VWAP

Connect to real brokers like Alpaca

Structure your code into a modular engine

Show how the Pollen bot works (from Stefan's doc)

We‚Äôll bring everything full circle ‚Äî strategy ‚Üí execution ‚Üí feedback loop.

ü§ñ The Beginner's Blueprint to Day Trading with Python
Part 10: Build Your First Real Trading Bot (MACD + RSI + VWAP + Broker Integration)
‚ú¶ What Are We Building?
We‚Äôre recreating the essence of the Pollen trading bot (from Stefan‚Äôs doc) using:

MACD, RSI, and VWAP for strategy

Alpaca API for paper/live trading

Modular components (so you can swap strategies or data sources)

A daily schedule to run the bot

‚ú¶ Pollen Strategy: Gravity-Based Mean Reversion
"Everything returns to the mean."

Core signals:
MACD crossover = momentum shift

RSI under 30 or over 70 = extremes

VWAP = where most volume traded ‚Äî think of it as a ‚Äúmagnet‚Äù

You want:

Buy: MACD cross up + RSI < 35 + Price < VWAP

Sell: MACD cross down + RSI > 65 + Price > VWAP

üíæ Alpaca Setup (Free Broker API)
Create an account: https://alpaca.markets

Get API Key + Secret (paper trading)

Install the SDK:

bash
Copy
Edit
pip install alpaca-trade-api
üß† Strategy Logic (in Plain English)
Pull last 100 candles (5-minute intervals)

Calculate RSI(14), MACD(12/26/9), VWAP

If buy conditions met ‚Üí submit market order

If sell conditions met ‚Üí close position

Log every action taken

üìÑ Full Bot Code
üìÑ bots/macd_rsi_vwap_bot.py

python
Copy
Edit
import pandas as pd
import numpy as np
from alpaca_trade_api.rest import REST, TimeFrame
import datetime

API_KEY = 'YOUR_API_KEY'
API_SECRET = 'YOUR_SECRET'
BASE_URL = 'https://paper-api.alpaca.markets'

api = REST(API_KEY, API_SECRET, BASE_URL)

def get_data(symbol, limit=100):
    now = datetime.datetime.now()
    bars = api.get_bars(symbol, TimeFrame.Minute, start=now - datetime.timedelta(days=2), limit=limit).df
    bars = bars[bars['symbol'] == symbol]
    return bars

def calc_indicators(df):
    df['EMA12'] = df['close'].ewm(span=12).mean()
    df['EMA26'] = df['close'].ewm(span=26).mean()
    df['MACD'] = df['EMA12'] - df['EMA26']
    df['Signal'] = df['MACD'].ewm(span=9).mean()

    delta = df['close'].diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.rolling(window=14).mean()
    avg_loss = loss.rolling(window=14).mean()
    rs = avg_gain / avg_loss
    df['RSI'] = 100 - (100 / (1 + rs))

    df['VWAP'] = (df['close'] * df['volume']).cumsum() / df['volume'].cumsum()
    return df

def check_signals(df):
    latest = df.iloc[-1]
    prev_macd = df['MACD'].iloc[-2]
    prev_signal = df['Signal'].iloc[-2]

    buy = (latest['MACD'] > latest['Signal'] and prev_macd <= prev_signal
           and latest['RSI'] < 35
           and latest['close'] < latest['VWAP'])

    sell = (latest['MACD'] < latest['Signal'] and prev_macd >= prev_signal
            and latest['RSI'] > 65
            and latest['close'] > latest['VWAP'])

    return buy, sell

def run_bot(symbol='AAPL'):
    df = get_data(symbol)
    df = calc_indicators(df)
    buy, sell = check_signals(df)

    position = None
    try:
        pos = api.get_position(symbol)
        position = float(pos.qty)
    except:
        pass

    if buy and not position:
        print(f"BUY {symbol}")
        api.submit_order(symbol=symbol, qty=1, side='buy', type='market', time_in_force='gtc')
    elif sell and position:
        print(f"SELL {symbol}")
        api.submit_order(symbol=symbol, qty=1, side='sell', type='market', time_in_force='gtc')
    else:
        print(f"HOLD {symbol} | MACD: {df.iloc[-1]['MACD']:.2f}, RSI: {df.iloc[-1]['RSI']:.2f}")

if __name__ == '__main__':
    run_bot("AAPL")
üß† How to Run It
You can:

Run it every 15 minutes with a cronjob / task scheduler

Expand it to check multiple stocks

Store logs in a .csv or database

‚ú® Bonus: Logging + Alerts
To log every action:

python
Copy
Edit
import logging

logging.basicConfig(filename='trading_log.txt', level=logging.INFO)

# Replace print() with:
logging.info(f"{datetime.datetime.now()} - BUY {symbol}")
For alerts, add:

python
Copy
Edit
import os
os.system('say "BUY SIGNAL"')  # macOS voice alert
üß± Modular Architecture You Can Build
bash
Copy
Edit
/bots/
‚îú‚îÄ‚îÄ indicators.py       # All your tech indicators
‚îú‚îÄ‚îÄ strategies.py       # Your signal logic
‚îú‚îÄ‚îÄ broker.py           # Alpaca functions (submit, check, get_data)
‚îú‚îÄ‚îÄ main.py             # Ties everything together
Keep it pluggable, so you can:

Swap brokers

Test new strategies

Run in paper mode before going live

‚ú¶ Coming Up Next: Final Recap and Future Paths
In the final Part 11, I‚Äôll:

Recap what you‚Äôve built

Suggest next-level paths (e.g. AI, live LSTM, HFT, portfolio rebalancers)

Point you to tools to scale it to pro level

üèÅ The Beginner's Blueprint to Day Trading with Python
Part 11: The Recap, the Roadmap, and the Next Level
‚ú¶ What You've Built
Over the course of this tutorial, you‚Äôve built:

‚úî Price Analysis Tools
‚Ä¢ Candlestick charts
‚Ä¢ EMA, RSI, MACD, VWAP
‚Ä¢ Real-time volume and sentiment overlays

‚úî Naive Model + Benchmarking
‚Ä¢ First price predictor
‚Ä¢ SMAPE, RMSE, MAE metrics
‚Ä¢ Visual forecast vs reality

‚úî Indicator Overlays
‚Ä¢ Multi-pane charts
‚Ä¢ RSI/MACD diagnostics
‚Ä¢ Candles + volume with Plotly

‚úî Stock Screener
‚Ä¢ S&P 500 pull
‚Ä¢ 52-week high/low scanner
‚Ä¢ Market cap + RSI filters
‚Ä¢ Excel export with full dataframe

‚úî Option Payoff Simulator
‚Ä¢ Binary calls/puts
‚Ä¢ Heaviside visualization
‚Ä¢ Black-Scholes digital valuation

‚úî Backtesting Framework
‚Ä¢ Mean reversion model
‚Ä¢ Zipline simulation
‚Ä¢ Weekly rebalance logic
‚Ä¢ Pyfolio full risk analysis

‚úî Real Browser Bot
‚Ä¢ Fidelity login via pyautogui + Shortkeys
‚Ä¢ Secure partial credential handling
‚Ä¢ Page scrape and element click automation

‚úî Fully Functional Trading Bot
‚Ä¢ MACD + RSI + VWAP strategy
‚Ä¢ Alpaca paper/live execution
‚Ä¢ Modular architecture
‚Ä¢ Logging, alerts, and signal logic

You now have a skeleton to build any strategy on top of.

‚ú¶ What Comes Next?
1. Expand Your Strategy Library
Try new models:

EMA crossovers (9/21, 20/50)

Bollinger Band reversion

News-based sentiment filter (use VADER with Yahoo headlines)

Intraday volatility + volume spikes

2. Backtest Everything
Use:

zipline-reloaded

backtrader

vectorbt (blazing fast, great for research)

Benchmark your ideas against:

SPY (buy-and-hold)

AAPL

Random strategies

If it can't beat random‚Ä¶ don't trade it.

3. Real Execution Tips
üõ°Ô∏è Always start in paper mode
üîê Never expose full keys
üíæ Log every trade with:

Time

Signal type

Price

Position size
üìâ Visualize drawdowns ‚Äî your emotions will betray you if you don‚Äôt prepare

4. Optional: Add Machine Learning
Yes, you can add:

LSTMs for forecasting

Reinforcement learning for trade decision

Random Forests to classify ‚Äúgood‚Äù vs ‚Äúbad‚Äù setups

But‚Ä¶ don‚Äôt start there.
Only add ML once your strategy logic is solid.

5. Portfolio-Level Stuff
Eventually you‚Äôll want:

Multiple asset strategies

Risk parity balancing

Automatic rebalancers

Sharpe/Sortino optimizers

Use:

cvxpy for constraint-based optimizers

pyfolio or empyrical for metrics

quantstats for beautiful reports

6. Schedule and Scale It
For a real-world deployment:

Use crontab or systemd (Linux)

Log to file or SQLite

Run a daily .py bot that pulls, evaluates, trades

Bonus:

Use streamlit to build a web dashboard to view your bot in action

‚ú¶ Final Thoughts
You‚Äôve now:

Written real trading strategies

Backtested across a decade of data

Built interactive visual dashboards

Created secure, stealthy browser bots

Wired in real broker APIs

Learned the real logic behind signals, risk, and execution

And you did it with nothing but open tools and Python.

‚ú® Suggested Next Projects (Pick Your Path)
üõ†Ô∏è Build a Live Strategy Switcher
‚Üí Automatically switch strategies based on volatility or VIX

üìä Make a Full Trading Journal App
‚Üí Track trades, annotate charts, log emotional decisions

üß† Train an AI to Predict Trend Strength
‚Üí Use MACD/RSI/VWAP as features ‚Äî build an ensemble classifier

üåê Deploy a Streamlit Trading Dashboard
‚Üí Show positions, stats, live news sentiment, chart overlays

‚öñÔ∏è Create a Multi-Asset Portfolio Manager
‚Üí Auto-hedge, rebalance, simulate future paths with Monte Carlo



